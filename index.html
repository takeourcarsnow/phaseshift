<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Wave Playground — Context-aware UI</title>
<style>
  :root {
    --bg: #0b0c10;
    --fg: #e6edf3;
    --muted: #a2a9b1;
    --accent: #00d1ff;
    --panel: #121417cc;
    --panel-border: #24272b;
    --btn: #1c2229;
    --btn-hover: #242c35;
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    background: var(--bg);
    color: var(--fg);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    overflow: hidden;
  }
  .app {
    position: fixed; inset: 0;
    display: grid;
    grid-template-columns: clamp(260px, 28vw, 420px) 1fr;
  }
  @media (max-width: 900px) {
    .app { grid-template-columns: 1fr; }
    aside { position: fixed; left: 0; right: 0; bottom: 0; top: auto; max-height: 70vh; z-index: 10; border-right: none; border-top: 1px solid var(--panel-border); border-radius: 16px 16px 0 0; }
    .panel.collapsed { height: 46px; overflow: hidden; }
  }
  canvas { display: block; width: 100%; height: 100%; touch-action: none; }

  aside {
    background: var(--panel);
    border-right: 1px solid var(--panel-border);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    overflow: auto;
  }

  .panel { padding: 14px 14px calc(80px + env(safe-area-inset-bottom)); }
  .topbar {
    position: sticky; top: 0; z-index: 2;
    background: linear-gradient(180deg, #121417f2, #121417cc 70%, #12141700);
    border-bottom: 1px solid #1d2126;
    margin: -14px -14px 8px; padding: 12px 14px 6px;
    display: flex; align-items: center; gap: 10px;
  }
  .title { font-size: 14px; font-weight: 700; letter-spacing: .6px; }
  .chip { font-size: 11px; color: #cbd3dc; border: 1px solid #2b2e34; background: #161a1f; padding: 4px 8px; border-radius: 999px; }
  .chip.warn { color: #ffd67d; border-color: #3a2f05; background: #1b1400; }
  .spacer { flex: 1; }

  .btn { height: 30px; padding: 0 10px; border-radius: 8px; border: 1px solid #2b2e34; background: var(--btn); color: var(--fg); }
  .btn:hover { background: var(--btn-hover); }

  .sec { margin: 16px 0 8px; padding-top: 8px; border-top: 1px dashed #262a2f; color: var(--fg); font-weight: 600; letter-spacing: .4px; }

  .group {
    display: grid;
    grid-template-columns: 1fr 112px;
    gap: 10px;
    align-items: center;
    margin: 8px 0;
  }
  .group.wide { grid-template-columns: 1fr; }
  .group label { display: flex; align-items: center; gap: 8px; font-size: 12px; color: var(--muted); user-select: none; }
  .group input[type="range"] { width: 100%; }
  .group input[type="checkbox"] { transform: translateY(1px); }
  .group input[type="color"] { width: 100%; height: 32px; background: #0000; border: none; }
  .group select, .group input[type="text"], .group input[type="number"] {
    width: 100%; height: 32px; border-radius: 8px; border: 1px solid #2b2e34; background: var(--btn); color: var(--fg); padding: 0 10px; font-size: 12px;
  }
  .value { text-align: right; font-variant-numeric: tabular-nums; color: var(--muted); }

  .subtle { font-size: 11px; color: var(--muted); }
  .hidden { display: none !important; }
  .hint { font-size: 11px; color: var(--muted); }

  .footer {
    position: sticky; bottom: 0; padding: 10px 0 0; margin-top: 8px;
    background: linear-gradient(0deg, #121417f2, #12141700 60%); border-top: 1px solid #1d2126;
  }
  .btn-row { display: flex; gap: 8px; padding: 8px 14px; }
  .note { font-size: 11px; color: var(--muted); margin: 6px 14px 12px; }
  .mono { font-family: ui-monospace, Menlo, Consolas, monospace; }

  @media (max-width: 520px) {
    .group { grid-template-columns: 1fr; }
    .value { display: none; }
  }
</style>
</head>
<body>
  <div class="app">
    <aside>
      <div class="panel" id="panel">
        <div class="topbar">
          <div class="title">Wave Playground</div>
          <span class="chip" id="fpsChip">FPS: —</span>
          <span class="chip" id="detailChip">Detail: —</span>
          <span class="chip" id="ctxChip" aria-live="polite">OK</span>
          <div class="spacer"></div>
          <button class="btn" id="pauseBtn">Pause</button>
          <button class="btn" id="togglePanel">Menu</button>
        </div>

        <div class="sec">Waves</div>
        <div class="group">
          <label>Count</label><div class="value" id="v_waveCount"></div>
          <input id="waveCount" type="range" min="1" max="128" step="1">
        </div>
        <div class="group">
          <label>Amplitude</label><div class="value" id="v_amplitude"></div>
          <input id="amplitude" type="range" min="0" max="300" step="1">
        </div>
        <div class="group">
          <label>Auto amplitude</label>
          <div class="value"><input id="autoAmplitude" type="checkbox"></div>
        </div>
        <div class="group wide subtle" id="row_ampHint">
          <span id="ampHint" class="mono"></span>
        </div>
        <div class="group">
          <label>Frequency (cycles)</label><div class="value" id="v_frequency"></div>
          <input id="frequency" type="range" min="0.2" max="6" step="0.1">
        </div>
        <div class="group">
          <label>Phase speed</label><div class="value" id="v_speed"></div>
          <input id="speed" type="range" min="0" max="4" step="0.01">
        </div>

        <div class="group">
          <label>Vertical spacing (base)</label><div class="value" id="v_minGap"></div>
          <input id="minGap" type="range" min="0" max="120" step="1">
        </div>
        <div class="group">
          <label>Auto min-gap</label>
          <div class="value"><input id="autoMinGap" type="checkbox"></div>
        </div>

        <div class="group">
          <label>Layer spread</label><div class="value" id="v_spread"></div>
          <input id="spread" type="range" min="0.25" max="1.5" step="0.01">
        </div>
        <div class="group">
          <label>Band center</label><div class="value" id="v_bandCenter"></div>
          <input id="bandCenter" type="range" min="0" max="1" step="0.01">
        </div>

        <div class="group">
          <label>Shape</label>
          <select id="shape">
            <option value="sine">Sine</option>
            <option value="triangle">Triangle</option>
            <option value="square">Square</option>
            <option value="saw">Sawtooth</option>
            <option value="pulse">Pulse</option>
          </select>
        </div>
        <div class="group hidden" id="row_pulseDuty">
          <label>Pulse duty</label><div class="value" id="v_duty"></div>
          <input id="pulseDuty" type="range" min="0.05" max="0.95" step="0.01">
        </div>

        <div class="sec">Flow</div>
        <div class="group">
          <label>Direction</label>
          <select id="direction">
            <option value="right">Right →</option>
            <option value="left">← Left</option>
          </select>
        </div>
        <div class="group">
          <label>Flow angle (deg)</label><div class="value" id="v_flowAngle"></div>
          <input id="flowAngle" type="range" min="-90" max="90" step="1">
        </div>
        <div class="group">
          <label>Line tilt (deg)</label><div class="value" id="v_tiltDeg"></div>
          <input id="tiltDeg" type="range" min="-45" max="45" step="0.5">
        </div>

        <div class="sec">Turbulence</div>
        <div class="group">
          <label>Type</label>
          <select id="turbType">
            <option value="none">None</option>
            <option value="sine">Sine</option>
            <option value="noise">Noise</option>
            <option value="perlin">Perlin</option>
            <option value="vortex">Vortex</option>
            <option value="chaos">Chaos</option>
          </select>
        </div>
        <div class="group hidden" id="row_turbInt">
          <label>Intensity</label><div class="value" id="v_turbInt"></div>
          <input id="turbInt" type="range" min="0" max="1.5" step="0.01">
        </div>
        <div class="group hidden" id="row_turbScale">
          <label>Scale</label><div class="value" id="v_turbScale"></div>
          <input id="turbScale" type="range" min="0.0003" max="0.01" step="0.0001">
        </div>
        <div class="group hidden" id="row_turbSpeed">
          <label>Speed</label><div class="value" id="v_turbSpeed"></div>
          <input id="turbSpeed" type="range" min="0" max="2" step="0.01">
        </div>
        <div class="group hidden" id="row_noiseSeed">
          <label>Noise seed</label>
          <input id="noiseSeed" type="number" class="mono" step="1" min="0" max="2147483647">
        </div>
        <div class="group hidden" id="row_reseed">
          <button class="btn" id="reseed">Re-seed</button>
          <div class="subtle">For noise/perlin/chaos</div>
        </div>

        <div class="sec">Interaction</div>
        <div class="group">
          <label>Mode</label>
          <select id="interMode">
            <option value="off">Off</option>
            <option value="push">Push</option>
            <option value="pull">Pull</option>
            <option value="gravity">Gravity</option>
            <option value="swirl">Swirl</option>
          </select>
        </div>
        <div class="group hidden" id="row_interStrength">
          <label>Strength</label><div class="value" id="v_interStrength"></div>
          <input id="interStrength" type="range" min="0" max="4" step="0.01">
        </div>
        <div class="group hidden" id="row_interRadius">
          <label>Radius</label><div class="value" id="v_interRadius"></div>
          <input id="interRadius" type="range" min="8" max="500" step="1">
        </div>
        <div class="group">
          <label>Auto radius</label>
          <div class="value"><input id="autoInterRadius" type="checkbox"></div>
        </div>

        <div class="sec">Physics</div>
        <div class="group">
          <label>Elasticity (to shape)</label><div class="value" id="v_spring"></div>
          <input id="spring" type="range" min="1" max="180" step="1">
        </div>
        <div class="group">
          <label>Neighbor coupling</label><div class="value" id="v_neighbor"></div>
          <input id="neighbor" type="range" min="0" max="1200" step="10">
        </div>
        <div class="group">
          <label>Damping</label><div class="value" id="v_damping"></div>
          <input id="damping" type="range" min="0" max="24" step="0.1">
        </div>
        <div class="group" id="row_sepK">
          <label>Separation strength</label><div class="value" id="v_sepK"></div>
          <input id="sepK" type="range" min="0" max="2" step="0.01">
        </div>
        <div class="group">
          <label>Keep inside</label>
          <div class="value"><input id="keepInside" type="checkbox"></div>
        </div>

        <div class="sec">Visual</div>
        <div class="group">
          <label>Line width</label><div class="value" id="v_lineWidth"></div>
          <input id="lineWidth" type="range" min="0.5" max="10" step="0.1">
        </div>
        <div class="group">
          <label>Line style</label>
          <select id="lineStyle">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
        </div>
        <div class="group">
          <label>Color mode</label>
          <select id="colorMode">
            <option value="custom">Custom</option>
            <option value="rainbow">Rainbow</option>
            <option value="velocity">Velocity</option>
          </select>
        </div>
        <div class="group hidden" id="row_lineColor">
          <label>Custom color</label>
          <input id="lineColor" type="color">
        </div>
        <div class="group">
          <label>Background</label>
          <input id="bgColor" type="color">
        </div>
        <div class="group">
          <label>Blend mode</label>
          <select id="blendMode">
            <option value="source-over">Normal</option>
            <option value="lighter">Lighter</option>
            <option value="screen">Screen</option>
            <option value="overlay">Overlay</option>
            <option value="soft-light">Soft light</option>
            <option value="difference">Difference</option>
          </select>
        </div>

        <div class="group">
          <label>Glow</label>
          <div class="value"><input id="glowEnabled" type="checkbox"></div>
        </div>
        <div class="group hidden" id="row_glow">
          <label>Glow size</label><div class="value" id="v_glow"></div>
          <input id="glow" type="range" min="0" max="50" step="1">
        </div>
        <div class="group hidden" id="row_glowColor">
          <label>Glow color</label>
          <input id="glowColor" type="color">
        </div>

        <div class="group">
          <label>Plex (trail)</label>
          <div class="value"><input id="plexEnabled" type="checkbox"></div>
        </div>
        <div class="group hidden" id="row_plex">
          <label>Trail fade</label><div class="value" id="v_plex"></div>
          <input id="plex" type="range" min="0" max="1" step="0.01">
        </div>

        <div class="sec">Performance</div>
        <div class="group">
          <label>Detail (px/sample)</label><div class="value" id="v_detail"></div>
          <input id="detail" type="range" min="3" max="16" step="1">
        </div>
        <div class="group">
          <label>Auto detail</label>
          <div class="value"><input id="autoDetail" type="checkbox"></div>
        </div>

        <div class="sec">Presets</div>
        <div class="group">
          <label>Load preset</label>
          <select id="presetSelect"></select>
        </div>
        <div class="group">
          <label>Name</label>
          <input id="presetName" type="text" placeholder="My preset">
        </div>
        <div class="btn-row" style="margin-top: -4px;">
          <button class="btn" id="savePreset">Save</button>
          <button class="btn" id="deletePreset">Delete</button>
        </div>
        <div class="btn-row">
          <button class="btn" id="exportPreset">Export JSON</button>
          <button class="btn" id="importPreset">Import JSON</button>
        </div>

        <div class="note">Context-aware controls, layer spread and band center, flow direction/angle, visual tilt, auto amplitude/radius. Hotkeys: Space pause, M menu, R randomize, C center pointer, S screenshot.</div>

        <div class="footer">
          <div class="btn-row">
            <button class="btn" id="randomize">Randomize</button>
            <button class="btn" id="resetCam">Center Pointer</button>
          </div>
        </div>
      </div>
    </aside>
    <main><canvas id="c" aria-label="Interactive wave canvas"></canvas></main>
  </div>

<script>
(() => {
  // ---------- Utilities ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const TAU = Math.PI * 2;
  const DEG = Math.PI / 180;
  const byId = (id) => document.getElementById(id);
  const hsl = (h, s, l) => `hsl(${Math.round(h)}, ${Math.round(s)}%, ${Math.round(l)}%)`;
  const frac = (x) => x - Math.floor(x);

  // ---------- Noise ----------
  function Perlin(seed = 1337) {
    let p = new Uint8Array(512);
    let perm = new Uint8Array(512);
    function reseed(s) {
      let x = (s|0) || 1;
      for (let i = 0; i < 256; i++) { x = (1103515245 * x + 12345) & 0x7fffffff; p[i] = i; perm[i] = x & 255; }
      for (let i = 255; i > 0; i--) { const j = perm[i] % (i + 1); const t = p[i]; p[i] = p[j]; p[j] = t; }
      for (let i = 0; i < 256; i++) p[256 + i] = p[i];
    }
    reseed(seed);
    const grad2 = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
    const fade = t => t*t*t*(t*(t*6-15)+10);
    function dot(gx, gy, x, y) { return gx*x + gy*y; }
    function noise2D(x, y) {
      const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
      const xf = x - Math.floor(x), yf = y - Math.floor(y);
      const tl = p[X + p[Y]] % 8, tr = p[X + 1 + p[Y]] % 8, bl = p[X + p[Y + 1]] % 8, br = p[X + 1 + p[Y + 1]] % 8;
      const u = fade(xf), v = fade(yf);
      const x1 = dot(grad2[tl][0], grad2[tl][1], xf,     yf    ) * (1 - u) + dot(grad2[tr][0], grad2[tr][1], xf - 1, yf    ) * u;
      const x2 = dot(grad2[bl][0], grad2[bl][1], xf,     yf - 1) * (1 - u) + dot(grad2[br][0], grad2[br][1], xf - 1, yf - 1) * u;
      return x1 * (1 - v) + x2 * v;
    }
    function fbm2(x, y, oct=4, lac=2, gain=0.5) {
      let amp = 0.5, freq = 1, sum = 0, norm = 0;
      for (let i=0; i<oct; i++) { sum += amp * noise2D(x*freq, y*freq); norm += amp; amp *= gain; freq *= lac; }
      return sum / norm;
    }
    return { noise2D, fbm2, reseed };
  }

  // ---------- Settings ----------
  const settings = {
    wave: {
      count: 5,
      amplitude: 120,
      frequency: 1.6,
      speed: 0.6,
      minGap: 28,
      autoMinGap: true,
      shape: 'sine',
      pulseDuty: 0.25,
      autoAmplitude: false,
      // New controls
      spread: 1.0,        // packs lines (lower = tighter)
      bandCenter: 0.5,    // 0..1 center of band
      direction: 'right', // left/right flow
      flowAngleDeg: 0,    // wave propagation angle
      tiltDeg: 0          // visual line tilt
    },
    turbulence: { type: 'perlin', intensity: 0.35, scale: 0.0022, speed: 0.22, octaves: 3, seed: ((Math.random()*1e9)|0) },
    interaction: { mode: 'push', strength: 1.2, radius: 160, autoRadius: true },
    physics: { spring: 80, neighbor: 420, damping: 10.5, sepK: 0.6, keepInside: false },
    visual: {
      lineWidth: 2.2, lineStyle: 'solid',
      colorMode: 'rainbow', lineColor: '#00d1ff', bgColor: '#0b0c10',
      glowEnabled: false, glow: 18, glowColor: '#ffffff',
      blendMode: 'source-over',
      plexEnabled: false, plex: 0.1
    },
    system: {
      detail: 8, autoDetail: true, targetFPS: 60, paused: false,
      reduceMotion: window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches
    },
    internal: { rainbowShift: 0, velocityHueMin: 200, velocityHueMax: 360, amplitudeCap: 999 }
  };

  // ---------- Canvas / Resize ----------
  const canvas = byId('c');
  const ctx = canvas.getContext('2d');
  let dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let W = 0, H = 0;

  let stride = settings.system.detail;
  let sampleCount = 0;
  let xCoords = new Float32Array(0);
  let xNorms = new Float32Array(0);
  let preXScaled = new Float32Array(0);

  function computeSamples() {
    sampleCount = Math.max(32, Math.floor(W / stride) + 1);
    xCoords = new Float32Array(sampleCount);
    xNorms = new Float32Array(sampleCount);
    const step = W / (sampleCount - 1);
    for (let i=0; i<sampleCount; i++) { xCoords[i] = i * step; xNorms[i] = xCoords[i] / W; }
    preXScaled = new Float32Array(sampleCount);
    layers.forEach(l => l.resample());
    byId('detailChip').textContent = `Detail: ${stride}px`;
    const lbl = byId('v_detail'); if (lbl) lbl.textContent = `${stride}`;
  }

  function resize() {
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    W = Math.floor(rect.width);
    H = Math.floor(rect.height);
    canvas.width = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    computeSamples();
    applyContextLimits();
  }
  window.addEventListener('resize', resize);

  // ---------- Pointer ----------
  const pointer = { x: 0, y: 0, sx: 0, sy: 0, down: false };
  function setPointer(e) {
    const r = canvas.getBoundingClientRect();
    pointer.x = (e.clientX - r.left);
    pointer.y = (e.clientY - r.top);
  }
  window.addEventListener('pointermove', (e) => setPointer(e), { passive: true });
  window.addEventListener('pointerdown', (e) => { pointer.down = true; setPointer(e); });
  window.addEventListener('pointerup', () => { pointer.down = false; });

  // ---------- Layer baselines ----------
  function computeLayerBaseline(total, idx) {
    if (total <= 0) return H * clamp(settings.wave.bandCenter, 0.02, 0.98);
    const c = clamp(settings.wave.bandCenter, 0.02, 0.98);
    const s = clamp(settings.wave.spread, 0.25, 1.5);
    const t = (idx + 1) / (total + 1); // 0..1
    const t2 = clamp(c + (t - c) * s, 0.02, 0.98);
    return H * t2;
  }

  // ---------- Layers ----------
  class Layer {
    constructor(idx) {
      this.idx = idx;
      this.alpha = 1; this.targetAlpha = 1;
      this.baseY = 0; this.targetBaseY = 0;
      this.points = new Float32Array(sampleCount);
      this.vel = new Float32Array(sampleCount);
      const y0 = computeLayerBaseline(Math.max(1, desiredWaveCount), idx);
      this.baseY = y0; this.targetBaseY = y0;
      for (let i=0; i<sampleCount; i++) { this.points[i] = y0; this.vel[i] = 0; }
      this.alive = true;
    }
    resample() {
      const oldY = this.points, oldV = this.vel;
      const lenOld = oldY.length;
      const newY = new Float32Array(sampleCount);
      const newV = new Float32Array(sampleCount);
      for (let i=0; i<sampleCount; i++) {
        const t = (i * (lenOld - 1)) / (sampleCount - 1);
        const i0 = t|0, i1 = Math.min(lenOld - 1, i0 + 1), f = t - i0;
        newY[i] = (oldY[i0] || this.baseY) * (1 - f) + (oldY[i1] || this.baseY) * f;
        newV[i] = (oldV[i0] || 0) * (1 - f) + (oldV[i1] || 0) * f;
      }
      this.points = newY; this.vel = newV;
    }
    updateBaseline(total, i) {
      this.idx = i;
      this.targetBaseY = computeLayerBaseline(total, i);
      this.baseY = lerp(this.baseY, this.targetBaseY, 0.08);
      this.alpha = lerp(this.alpha, this.targetAlpha, 0.08);
      if (this.targetAlpha === 0 && Math.abs(this.alpha) < 0.01) this.alive = false;
    }
  }
  let layers = [];
  let desiredWaveCount = settings.wave.count;

  function ensureLayerCount() {
    for (let i = desiredWaveCount; i < layers.length; i++) layers[i].targetAlpha = 0;
    while (layers.filter(l => l.alive).length < desiredWaveCount) layers.push(new Layer(layers.length));
    layers = layers.filter(l => l.alive);
    for (let i=0; i<layers.length; i++) layers[i].updateBaseline(desiredWaveCount, i);
  }

  // ---------- Turbulence ----------
  let perlin = Perlin(settings.turbulence.seed);
  function turbulenceOffset(type, xScaled, y, t) {
    const T = settings.turbulence;
    if (type === 'none' || T.intensity === 0) return 0;
    switch (type) {
      case 'sine': {
        const s = T.scale, sp = T.speed;
        const v = Math.sin((xScaled/s)*TAU + t*sp*TAU) * 0.5
                + Math.sin((y*s)*TAU - t*sp*1.7*TAU) * 0.5;
        return v * T.intensity * 100;
      }
      case 'noise': {
        const s = T.scale, sp = T.speed;
        const v = Math.sin(perlin.noise2D(xScaled + t*sp, y*s - t*sp) * Math.PI);
        return v * T.intensity * 120;
      }
      case 'perlin': {
        const s = T.scale, sp = T.speed;
        const v = perlin.fbm2(xScaled + t*sp, y*s - t*sp, T.octaves, 2, 0.5);
        return v * T.intensity * 140;
      }
      case 'vortex': {
        const cx = pointer.down ? pointer.sx : W * 0.5;
        const cy = pointer.down ? pointer.sy : H * 0.5;
        const dx = (xScaled / (settings.turbulence.scale || 1)) - cx;
        const dy = y - cy;
        const r = Math.hypot(dx, dy) + 1e-3;
        const inv = Math.exp(-r / (settings.interaction.radius*1.2 + 1));
        const vy = (dx / r) * inv;
        return vy * T.intensity * 240;
      }
      case 'chaos': {
        const s = T.scale, sp = T.speed;
        const a = perlin.fbm2(xScaled*0.6 + t*sp*1.3, y*s*0.7 - t*sp*0.9, 4, 2.2, 0.55);
        const b = perlin.noise2D(xScaled*1.9 - t*sp*0.7, y*s*1.7 + t*sp*1.1);
        return (a*0.7 + b*0.3) * T.intensity * 180;
      }
      default: return 0;
    }
  }

  // ---------- Simulation ----------
  const fixedDt = 1/60;
  let accumulator = 0;
  let time = 0;

  function simulate(dt) {
    accumulator += dt;
    while (accumulator >= fixedDt) {
      step(fixedDt);
      accumulator -= fixedDt;
      time += fixedDt;
    }
  }

  function effectiveMinGap() {
    const V = settings.visual;
    const base = settings.wave.minGap;
    if (!settings.wave.autoMinGap) return base;
    const glowWidth = V.glowEnabled ? V.glow * 0.22 : 0;
    return base + V.lineWidth * 1.1 + glowWidth;
  }

  function step(dt) {
    const Wv = settings.wave, Ph = settings.physics, Tb = settings.turbulence, It = settings.interaction;

    pointer.sx = lerp(pointer.sx, pointer.x, 0.35);
    pointer.sy = lerp(pointer.sy, pointer.y, 0.35);

    for (let i=0; i<layers.length; i++) layers[i].updateBaseline(desiredWaveCount, i);

    // Precompute turbulence x
    const s = Tb.scale;
    for (let i=0; i<sampleCount; i++) preXScaled[i] = xCoords[i] * s;

    // Flow direction and angle
    const dir = (Wv.direction === 'left') ? -1 : 1;
    const timePhase = dir * time * Wv.speed;
    const ang = Wv.flowAngleDeg * DEG;
    const cosA = Math.cos(ang), sinA = Math.sin(ang);
    const freq = Math.max(0.0001, Wv.frequency);
    const duty = clamp(Wv.pulseDuty, 0.05, 0.95);

    for (let L=0; L<layers.length; L++) {
      const layer = layers[L];
      const yArr = layer.points, vArr = layer.vel;
      const base = layer.baseY;
      const baseNorm = base / H;
      const uLayer = baseNorm * sinA; // constant per layer
      const amp = Wv.amplitude;
      const nb = Ph.neighbor, k = Ph.spring, c = Ph.damping;

      for (let i=0; i<sampleCount; i++) {
        const x = xCoords[i];
        const u = xNorms[i] * cosA + uLayer;              // oriented coordinate
        const p = frac(freq * u + timePhase);             // 0..1 phase
        const sinv = Math.sin(TAU * p);

        // Shape sampler
        let shapeVal = 0;
        switch (Wv.shape) {
          case 'sine': shapeVal = sinv; break;
          case 'triangle': {
            shapeVal = 2 * Math.abs(2 * (p - Math.floor(p + 0.5))) - 1;
            break;
          }
          case 'square': {
            const x = sinv * 6.0;
            shapeVal = x * (27 + x*x) / (27 + 9*x*x);
            break;
          }
          case 'saw': {
            shapeVal = 2 * (p - Math.floor(p + 0.5));
            break;
          }
          case 'pulse': {
            let v = (p < duty) ? 1 : -1;
            const blend = sinv * 0.5 + 0.5;
            v = lerp(v, sinv, 0.15) * (0.8 + 0.2 * blend);
            shapeVal = v;
            break;
          }
          default: shapeVal = sinv;
        }

        const targetY = base + shapeVal * amp;

        const turb = turbulenceOffset(Tb.type, preXScaled[i], yArr[i], time);

        let inter = 0;
        if (It.mode !== 'off') {
          const dx = x - pointer.sx;
          const dy = yArr[i] - pointer.sy;
          const dist = Math.hypot(dx, dy);
          const r = It.radius;
          if (dist < r) {
            const fall = 1 - (dist / r);
            const sI = It.strength * (pointer.down ? 1.0 : 0.7);
            if (It.mode === 'push') inter += (dy / (dist + 1e-3)) * sI * fall * 160;
            else if (It.mode === 'pull') inter -= (dy / (dist + 1e-3)) * sI * fall * 160;
            else if (It.mode === 'gravity') inter -= Math.sign(dy) * sI * fall * 80;
            else if (It.mode === 'swirl') inter += (dx / (dist + 1e-3)) * sI * fall * 180;
          }
        }

        const y = yArr[i], v = vArr[i];
        const left = i>0 ? yArr[i-1] : yArr[i];
        const right = i<sampleCount-1 ? yArr[i+1] : yArr[i];
        const lap = left - 2*y + right;

        const a = ((targetY + turb + inter) - y) * k + lap * nb - v * c;

        const nv = v + a * dt;
        let ny = y + nv * dt;

        if (Ph.keepInside) {
          const m = 6;
          if (ny < m) { ny = m; vArr[i] *= 0.5; }
          else if (ny > H - m) { ny = H - m; vArr[i] *= 0.5; }
        }

        vArr[i] = nv;
        yArr[i] = ny;
      }
    }

    // Separation to avoid overlap
    if (layers.length > 1) {
      const gap = effectiveMinGap();
      const sepK = Ph.sepK;
      let maxViol, pass = 0;
      const maxPass = 6;
      do {
        maxViol = 0;
        for (let dir = 0; dir < 2; dir++) {
          for (let i=0; i<sampleCount; i++) {
            for (let L=0; L<layers.length-1; L++) {
              const A = layers[L], B = layers[L+1];
              const diff = (B.points[i] - A.points[i]) - gap;
              if (diff < 0) {
                const push = -diff * 0.5;
                A.points[i] -= push; B.points[i] += push;
                A.vel[i] -= push * sepK; B.vel[i] += push * sepK;
                if (-diff > maxViol) maxViol = -diff;
              }
            }
          }
        }
        pass++;
      } while (maxViol > 0.5 && pass < maxPass);
    }
  }

  // ---------- Context engine ----------
  function spacingBetweenBaselines() {
    if (desiredWaveCount <= 1) return H;
    const i = Math.max(0, Math.floor(desiredWaveCount/2) - 1);
    const y1 = computeLayerBaseline(desiredWaveCount, i);
    const y2 = computeLayerBaseline(desiredWaveCount, i + 1);
    return Math.abs(y2 - y1);
  }

  function applyContextLimits() {
    const spacing = spacingBetweenBaselines();
    const safeAmplitude = Math.max(0, Math.floor((spacing - effectiveMinGap()) * 0.5));
    settings.internal.amplitudeCap = safeAmplitude;

    // Adapt amplitude slider max and auto limit
    const ampEl = byId('amplitude');
    if (ampEl) ampEl.max = Math.max(10, Math.round(safeAmplitude * 2));
    const hint = byId('ampHint');
    if (hint) hint.textContent = `Safe amplitude ≤ ${safeAmplitude}px (spacing ≈ ${Math.round(spacing)}px, min-gap ≈ ${Math.round(effectiveMinGap())}px)`;

    if (settings.wave.autoAmplitude) {
      const clamped = clamp(settings.wave.amplitude, 0, safeAmplitude);
      if (clamped !== settings.wave.amplitude) {
        settings.wave.amplitude = clamped;
        if (ampEl) ampEl.value = clamped;
        const lbl = byId('v_amplitude'); if (lbl) lbl.textContent = clamped.toFixed(0);
      }
    }

    // Adapt interaction radius max and auto
    const maxR = Math.round(Math.hypot(W, H) * 0.6);
    const rEl = byId('interRadius');
    if (rEl) rEl.max = String(maxR);
    if (settings.interaction.autoRadius) {
      const ideal = Math.round(Math.min(maxR, Math.min(W, H) * 0.35));
      if (ideal !== settings.interaction.radius) {
        settings.interaction.radius = ideal;
        if (rEl) rEl.value = ideal;
        const lblR = byId('v_interRadius'); if (lblR) lblR.textContent = ideal.toFixed(0);
      }
    }

    updateContextChip();
  }

  // ---------- Drawing ----------
  function draw() {
    const V = settings.visual;

    ctx.globalCompositeOperation = 'source-over';
    const plexAlpha = V.plexEnabled ? clamp(V.plex, 0, 1) : 1;
    ctx.globalAlpha = plexAlpha;
    ctx.fillStyle = V.bgColor;
    ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = 1;

    ctx.globalCompositeOperation = V.blendMode || 'source-over';
    ctx.lineJoin = 'round';
    ctx.lineCap = (V.lineStyle === 'dotted') ? 'round' : 'round';
    ctx.shadowBlur = V.glowEnabled ? V.glow : 0;
    ctx.shadowColor = V.glowColor;

    const tilt = Math.tan((settings.wave.tiltDeg || 0) * DEG);
    const xMid = W * 0.5;

    for (let L=0; L<layers.length; L++) {
      const layer = layers[L];
      if (layer.alpha <= 0.001) continue;

      ctx.lineWidth = V.lineWidth;
      if (V.lineStyle === 'solid') ctx.setLineDash([]);
      else if (V.lineStyle === 'dashed') ctx.setLineDash([12, 8]);
      else if (V.lineStyle === 'dotted') ctx.setLineDash([1, 18]);

      let strokeStyle = V.lineColor;
      if (V.colorMode === 'rainbow') {
        const hue = (settings.internal.rainbowShift + (L * (360 / Math.max(1, desiredWaveCount)))) % 360;
        strokeStyle = hsl(hue, 90, 60);
      } else if (V.colorMode === 'velocity') {
        let sum = 0; const v = layers[L].vel;
        for (let i=0; i<sampleCount; i++) sum += Math.abs(v[i]);
        const avgV = sum / sampleCount;
        const vNorm = clamp(avgV / 600, 0, 1);
        const hue = lerp(settings.internal.velocityHueMin, settings.internal.velocityHueMax, vNorm);
        strokeStyle = hsl(hue, 90, lerp(45, 70, 1 - vNorm));
      }

      ctx.globalAlpha = layer.alpha;
      ctx.strokeStyle = strokeStyle;
      ctx.beginPath();
      const yArr = layer.points;
      ctx.moveTo(xCoords[0], yArr[0] + tilt * (xCoords[0] - xMid));
      for (let i=1; i<sampleCount; i++) {
        const x = xCoords[i];
        ctx.lineTo(x, yArr[i] + tilt * (x - xMid));
      }
      ctx.stroke();
    }
  }

  // ---------- Performance / Loop ----------
  let last = performance.now();
  let fpsEMA = 60;
  function loop(now) {
    if (!settings.system.paused) {
      const dt = Math.min(0.05, (now - last) / 1000);
      simulate(dt);
      draw();
      settings.internal.rainbowShift = (settings.internal.rainbowShift + 0.2) % 360;
    }
    const dtms = now - last;
    if (dtms > 0) fpsEMA = lerp(fpsEMA, 1000 / dtms, 0.1);
    last = now;

    if (settings.system.autoDetail) {
      const target = settings.system.targetFPS;
      if (fpsEMA < target - 5 && stride < 16) setStride(stride + 1);
      else if (fpsEMA > target + 8 && stride > 4) setStride(stride - 1);
    }

    // Throttled chip updates
    if (!loop.lastFpsUpdate || now - loop.lastFpsUpdate > 250) {
      byId('fpsChip').textContent = `FPS: ${Math.round(fpsEMA)}`;
      loop.lastFpsUpdate = now;
    }
    updateContextChip(now);

    requestAnimationFrame(loop);
  }

  function setStride(px) {
    stride = clamp(Math.round(px), 3, 16);
    computeSamples();
  }

  // ---------- UI Binding ----------
  const setText = (id, val) => { const el = byId(id); if (el) el.textContent = String(val); };
  const show = (id, on) => { const el = byId(id); if (!el) return; el.classList.toggle('hidden', !on); };
  const enable = (id, on) => { const el = byId(id); if (!el) return; el.disabled = !on; };

  function bindRange(id, obj, key, fmt=(v)=>v) {
    const el = byId(id); const label = byId('v_'+key) || byId('v_'+id);
    if (!el) return;
    el.value = obj[key];
    if (label) label.textContent = fmt(obj[key]);
    el.oninput = () => {
      obj[key] = parseFloat(el.value);
      if (label) label.textContent = fmt(obj[key]);
      if (key === 'count') { desiredWaveCount = Math.round(obj[key]); ensureLayerCount(); applyContextLimits(); }
      if (key === 'pulseDuty') setText('v_duty', obj[key].toFixed(2));
      if (id === 'detail') setStride(obj[key]);
      applyContextLimits();
      updateVisibility();
    };
  }
  function bindSelect(id, obj, key) {
    const el = byId(id); if (!el) return;
    el.value = obj[key];
    el.onchange = () => { obj[key] = el.value; applyContextLimits(); updateVisibility(); };
  }
  function bindCheck(id, obj, key) {
    const el = byId(id); if (!el) return;
    el.checked = !!obj[key];
    el.oninput = () => { obj[key] = !!el.checked; applyContextLimits(); updateVisibility(); };
  }
  function bindColor(id, obj, key) {
    const el = byId(id); if (!el) return;
    el.value = obj[key];
    el.oninput = () => { obj[key] = el.value; };
  }

  function updateVisibility() {
    show('row_pulseDuty', settings.wave.shape === 'pulse');

    const tt = settings.turbulence.type;
    const turbOn = tt !== 'none';
    show('row_turbInt', turbOn);
    show('row_turbScale', turbOn);
    show('row_turbSpeed', turbOn);
    const needsSeed = (tt === 'noise' || tt === 'perlin' || tt === 'chaos');
    show('row_noiseSeed', needsSeed);
    show('row_reseed', needsSeed);

    const interOn = settings.interaction.mode !== 'off';
    show('row_interStrength', interOn);
    show('row_interRadius', interOn);

    show('row_sepK', settings.wave.count > 1);

    show('row_lineColor', settings.visual.colorMode === 'custom');

    show('row_glow', settings.visual.glowEnabled);
    show('row_glowColor', settings.visual.glowEnabled);
    show('row_plex', settings.visual.plexEnabled);

    enable('detail', !settings.system.autoDetail);

    applyContextLimits();
  }

  // ---------- Context status chip ----------
  let lastCtxUpdate = 0;
  function updateContextChip(now = performance.now()) {
    const chip = byId('ctxChip'); if (!chip) return;
    if (now - lastCtxUpdate < 250) return;
    lastCtxUpdate = now;

    const amp = settings.wave.amplitude;
    const cap = settings.internal.amplitudeCap || 0;
    const target = settings.system.targetFPS;
    const lowFPS = fpsEMA < target - 10;

    let msg = 'OK';
    chip.classList.remove('warn');
    if (amp > cap + 2) { msg = 'Overlap risk'; chip.classList.add('warn'); }
    if (lowFPS) { msg = 'Perf: auto-detail'; chip.classList.add('warn'); }
    chip.textContent = msg;
  }

  // ---------- Presets ----------
  const PRESET_KEY = 'wave_playground_presets_v3';
  const presetSelect = byId('presetSelect');
  const presetName = byId('presetName');

  const defaultPresets = {
    "Clean Rainbow": {
      wave:{count:5,amplitude:110,frequency:1.5,speed:0.5,minGap:28,autoMinGap:true,shape:'sine',pulseDuty:0.25},
      turbulence:{type:'perlin',intensity:0.25,scale:0.002,speed:0.18,octaves:3},
      interaction:{mode:'push',strength:0.8,radius:180},
      physics:{spring:70,neighbor:480,damping:10,sepK:0.6,keepInside:false},
      visual:{lineWidth:2.2,lineStyle:'solid',colorMode:'rainbow',lineColor:'#00d1ff',bgColor:'#0b0c10',glowEnabled:false,glow:18,glowColor:'#ffffff',blendMode:'source-over',plexEnabled:false,plex:0.1},
      system:{detail:8,autoDetail:true}
    },
    "Neon Storm": {
      wave:{count:6,amplitude:160,frequency:2.4,speed:1.2,minGap:24,autoMinGap:true,shape:'saw',pulseDuty:0.25},
      turbulence:{type:'chaos',intensity:0.9,scale:0.003,speed:0.6,octaves:4},
      interaction:{mode:'swirl',strength:1.5,radius:200},
      physics:{spring:110,neighbor:800,damping:12,sepK:0.8,keepInside:true},
      visual:{lineWidth:2.2,lineStyle:'dotted',colorMode:'rainbow',lineColor:'#ff00e5',bgColor:'#020307',glowEnabled:true,glow:26,glowColor:'#ffffff',blendMode:'screen',plexEnabled:true,plex:0.06},
      system:{detail:7,autoDetail:true}
    },
    "Glass Strings": {
      wave:{count:5,amplitude:70,frequency:1.8,speed:0.7,minGap:34,autoMinGap:true,shape:'triangle',pulseDuty:0.25},
      turbulence:{type:'sine',intensity:0.35,scale:0.0015,speed:0.35,octaves:3},
      interaction:{mode:'pull',strength:0.9,radius:160},
      physics:{spring:90,neighbor:620,damping:9,sepK:0.6,keepInside:false},
      visual:{lineWidth:3,lineStyle:'dashed',colorMode:'custom',lineColor:'#b7fffd',bgColor:'#0b0c10',glowEnabled:false,glow:20,glowColor:'#b7fffd',blendMode:'overlay',plexEnabled:false,plex:0.1},
      system:{detail:9,autoDetail:true}
    },
    "VelociGlow": {
      wave:{count:4,amplitude:140,frequency:1.1,speed:0.5,minGap:26,autoMinGap:true,shape:'square',pulseDuty:0.25},
      turbulence:{type:'perlin',intensity:0.4,scale:0.0016,speed:0.2,octaves:4},
      interaction:{mode:'gravity',strength:1.0,radius:240},
      physics:{spring:80,neighbor:500,damping:11,sepK:0.7,keepInside:true},
      visual:{lineWidth:2.6,lineStyle:'solid',colorMode:'velocity',lineColor:'#00ffd5',bgColor:'#0a0c10',glowEnabled:true,glow:18,glowColor:'#ffffff',blendMode:'lighter',plexEnabled:false,plex:0.09},
      system:{detail:8,autoDetail:true}
    }
  };

  function loadPresets() {
    const raw = localStorage.getItem(PRESET_KEY);
    let user = {};
    if (raw) { try { user = JSON.parse(raw); } catch {} }
    return { ...defaultPresets, ...user };
  }
  function savePresets(obj) { localStorage.setItem(PRESET_KEY, JSON.stringify(obj)); }

  function applyPreset(p) {
    Object.assign(settings.wave, p.wave || {});
    desiredWaveCount = Math.round(settings.wave.count);
    Object.assign(settings.turbulence, p.turbulence || {});
    Object.assign(settings.interaction, p.interaction || {});
    Object.assign(settings.physics, p.physics || {});
    Object.assign(settings.visual, p.visual || {});
    Object.assign(settings.system, p.system || {});
    ensureLayerCount();
    if (typeof settings.turbulence.seed === 'number') perlin.reseed(settings.turbulence.seed);
    syncControls();
    setStride(settings.system.detail);
    applyContextLimits();
  }

  function currentPresetObject() {
    return JSON.parse(JSON.stringify(settings));
  }

  function initPresetsUI() {
    const all = loadPresets();
    presetSelect.innerHTML = '';
    Object.keys(all).forEach(name => {
      const opt = document.createElement('option');
      opt.value = name; opt.textContent = name; presetSelect.appendChild(opt);
    });
    presetSelect.onchange = () => { applyPreset(all[presetSelect.value]); };
    byId('savePreset').onclick = () => {
      const name = (presetName.value || '').trim() || 'My preset';
      all[name] = currentPresetObject();
      savePresets(all);
      initPresetsUI();
      presetSelect.value = name;
    };
    byId('deletePreset').onclick = () => {
      const name = presetSelect.value;
      if (defaultPresets[name]) return;
      delete all[name]; savePresets(all); initPresetsUI();
    };
    byId('exportPreset').onclick = () => {
      const json = JSON.stringify(currentPresetObject(), null, 2);
      navigator.clipboard?.writeText(json).catch(()=>{});
      alert('Current settings copied to clipboard as JSON.');
    };
    byId('importPreset').onclick = async () => {
      const text = prompt('Paste preset JSON:');
      if (!text) return;
      try { const obj = JSON.parse(text); applyPreset(obj); } catch { alert('Invalid JSON'); }
    };
  }

  // ---------- Randomizer ----------
  function randomize() {
    const pick = arr => arr[(Math.random()*arr.length)|0];
    settings.wave.count = (Math.random()*8+2)|0; desiredWaveCount = settings.wave.count;
    settings.wave.amplitude = (Math.random()*160+40)|0;
    settings.wave.frequency = Math.random()*2.8+0.6;
    settings.wave.speed = Math.random()*1.3+0.1;
    settings.wave.minGap = (Math.random()*48+10)|0;
    settings.wave.shape = pick(['sine','triangle','square','saw','pulse']);
    settings.wave.pulseDuty = Math.random()*0.7+0.15;
    settings.wave.autoMinGap = true;

    // New
    settings.wave.spread = Math.random()*0.7 + 0.6;       // 0.6..1.3
    settings.wave.bandCenter = Math.random()*0.4 + 0.3;   // 0.3..0.7
    settings.wave.direction = pick(['left','right']);
    settings.wave.flowAngleDeg = Math.round((Math.random()*80 - 40)); // -40..40
    settings.wave.tiltDeg = Math.round((Math.random()*40 - 20)*2)/2; // -20..20 step .5

    settings.turbulence.type = pick(['none','sine','noise','perlin','vortex','chaos']);
    settings.turbulence.intensity = Math.random()*1.1;
    settings.turbulence.scale = Math.random()*0.0035+0.0005;
    settings.turbulence.speed = Math.random()*0.9;

    settings.interaction.mode = pick(['off','push','pull','gravity','swirl']);
    settings.interaction.strength = Math.random()*1.5+0.3;
    settings.interaction.radius = Math.random()*200+80;

    settings.physics.spring = Math.random()*80+40;
    settings.physics.neighbor = Math.random()*700+200;
    settings.physics.damping = Math.random()*10+6;
    settings.physics.sepK = Math.random()*0.9+0.3;
    settings.physics.keepInside = Math.random() < 0.5;

    settings.visual.lineWidth = Math.random()*3.5+1;
    settings.visual.lineStyle = pick(['solid','dashed','dotted']);
    settings.visual.colorMode = pick(['custom','rainbow','velocity']);
    settings.visual.lineColor = '#'+((Math.random()*0xffffff)|0).toString(16).padStart(6,'0');
    settings.visual.bgColor = '#'+((Math.random()*0x202020)|0 + 0x0b0c10).toString(16).slice(0,6).padStart(6,'0');
    settings.visual.glowEnabled = Math.random() < 0.35 ? true : false;
    settings.visual.glow = (Math.random()*22+6)|0;
    settings.visual.glowColor = '#ffffff';
    settings.visual.blendMode = pick(['source-over','lighter','screen','overlay','soft-light','difference']);
    settings.visual.plexEnabled = Math.random() < 0.3 ? true : false;
    settings.visual.plex = Math.random()*0.15+0.05;

    if (settings.system.autoDetail) setStride(stride);
    ensureLayerCount();
    syncControls();
    applyContextLimits();
  }

  // ---------- Hotkeys and system behaviors ----------
  function exportPNG() {
    canvas.toBlob(blob => {
      if (!blob) return;
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'wave.png';
      a.click();
      setTimeout(() => URL.revokeObjectURL(a.href), 1000);
    }, 'image/png');
  }

  document.addEventListener('keydown', (e) => {
    const tag = document.activeElement?.tagName;
    if (tag === 'INPUT' || tag === 'SELECT' || tag === 'TEXTAREA') return;
    switch (e.key.toLowerCase()) {
      case ' ': e.preventDefault(); byId('pauseBtn').click(); break;
      case 'm': byId('togglePanel').click(); break;
      case 'r': byId('randomize').click(); break;
      case 'c': byId('resetCam').click(); break;
      case 's': exportPNG(); break;
    }
  });

  // Respect reduced motion
  if (settings.system.reduceMotion) {
    settings.wave.speed *= 0.6;
    settings.system.autoDetail = true;
  }

  // Page visibility pause/resume
  let pausedByVisibility = false;
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      pausedByVisibility = !settings.system.paused;
      settings.system.paused = true;
      byId('pauseBtn').textContent = 'Resume';
    } else if (pausedByVisibility) {
      settings.system.paused = false;
      byId('pauseBtn').textContent = 'Pause';
      pausedByVisibility = false;
    }
  });

  // ---------- UI init/sync ----------
  function initUI() {
    bindRange('waveCount', settings.wave, 'count', v=>v.toFixed(0));
    bindRange('amplitude', settings.wave, 'amplitude', v=>v.toFixed(0));
    bindCheck('autoAmplitude', settings.wave, 'autoAmplitude');
    bindRange('frequency', settings.wave, 'frequency', v=>v.toFixed(2));
    bindRange('speed', settings.wave, 'speed', v=>v.toFixed(2));
    bindRange('minGap', settings.wave, 'minGap', v=>v.toFixed(0));
    bindCheck('autoMinGap', settings.wave, 'autoMinGap');

    bindRange('spread', settings.wave, 'spread', v=>`${Math.round(v*100)}%`);
    bindRange('bandCenter', settings.wave, 'bandCenter', v=>`${Math.round(v*100)}%`);

    bindSelect('shape', settings.wave, 'shape');
    bindRange('pulseDuty', settings.wave, 'pulseDuty', v=>v.toFixed(2));

    bindSelect('direction', settings.wave, 'direction');
    bindRange('flowAngle', settings.wave, 'flowAngleDeg', v=>`${v}°`);
    bindRange('tiltDeg', settings.wave, 'tiltDeg', v=>`${v}°`);

    bindSelect('turbType', settings.turbulence, 'type');
    bindRange('turbInt', settings.turbulence, 'intensity', v=>v.toFixed(2));
    bindRange('turbScale', settings.turbulence, 'scale', v=>Number(v).toFixed(4));
    bindRange('turbSpeed', settings.turbulence, 'speed', v=>v.toFixed(2));
    byId('noiseSeed').value = settings.turbulence.seed;
    byId('reseed').onclick = () => {
      const val = parseInt(byId('noiseSeed').value, 10);
      settings.turbulence.seed = (isFinite(val) ? val : ((Math.random()*1e9)|0));
      perlin.reseed(settings.turbulence.seed);
    };

    bindSelect('interMode', settings.interaction, 'mode');
    bindRange('interStrength', settings.interaction, 'strength', v=>v.toFixed(2));
    bindRange('interRadius', settings.interaction, 'radius', v=>v.toFixed(0));
    bindCheck('autoInterRadius', settings.interaction, 'autoRadius');

    bindRange('spring', settings.physics, 'spring', v=>v.toFixed(0));
    bindRange('neighbor', settings.physics, 'neighbor', v=>v.toFixed(0));
    bindRange('damping', settings.physics, 'damping', v=>v.toFixed(1));
    bindRange('sepK', settings.physics, 'sepK', v=>v.toFixed(2));
    bindCheck('keepInside', settings.physics, 'keepInside');

    bindRange('lineWidth', settings.visual, 'lineWidth', v=>v.toFixed(1));
    bindSelect('lineStyle', settings.visual, 'lineStyle');
    bindSelect('colorMode', settings.visual, 'colorMode');
    bindColor('lineColor', settings.visual, 'lineColor');
    bindColor('bgColor', settings.visual, 'bgColor');
    bindSelect('blendMode', settings.visual, 'blendMode');
    bindCheck('glowEnabled', settings.visual, 'glowEnabled');
    bindRange('glow', settings.visual, 'glow', v=>v.toFixed(0));
    bindColor('glowColor', settings.visual, 'glowColor');
    bindCheck('plexEnabled', settings.visual, 'plexEnabled');
    bindRange('plex', settings.visual, 'plex', v=>v.toFixed(2));

    bindRange('detail', settings.system, 'detail', v=>v.toFixed(0));
    bindCheck('autoDetail', settings.system, 'autoDetail');

    byId('togglePanel').onclick = () => {
      byId('panel').classList.toggle('collapsed');
      requestAnimationFrame(resize);
    };
    byId('pauseBtn').onclick = () => {
      settings.system.paused = !settings.system.paused;
      byId('pauseBtn').textContent = settings.system.paused ? 'Resume' : 'Pause';
    };
    byId('randomize').onclick = randomize;
    byId('resetCam').onclick = () => { pointer.x = W*0.5; pointer.y = H*0.5; pointer.sx = pointer.x; pointer.sy = pointer.y; };

    initPresetsUI();
    syncControls();
  }

  function syncControls() {
    const pairs = [
      ['v_waveCount', settings.wave.count],
      ['v_amplitude', settings.wave.amplitude],
      ['v_frequency', settings.wave.frequency.toFixed(2)],
      ['v_speed', settings.wave.speed.toFixed(2)],
      ['v_minGap', settings.wave.minGap],
      ['v_spread', `${Math.round(settings.wave.spread*100)}%`],
      ['v_bandCenter', `${Math.round(settings.wave.bandCenter*100)}%`],
      ['v_duty', settings.wave.pulseDuty.toFixed(2)],
      ['v_flowAngle', `${settings.wave.flowAngleDeg}°`],
      ['v_tiltDeg', `${settings.wave.tiltDeg}°`],
      ['v_turbInt', settings.turbulence.intensity.toFixed(2)],
      ['v_turbScale', settings.turbulence.scale.toFixed(4)],
      ['v_turbSpeed', settings.turbulence.speed.toFixed(2)],
      ['v_interStrength', settings.interaction.strength.toFixed(2)],
      ['v_interRadius', settings.interaction.radius.toFixed(0)],
      ['v_spring', settings.physics.spring.toFixed(0)],
      ['v_neighbor', settings.physics.neighbor.toFixed(0)],
      ['v_damping', settings.physics.damping.toFixed(1)],
      ['v_sepK', settings.physics.sepK.toFixed(2)],
      ['v_lineWidth', settings.visual.lineWidth.toFixed(1)],
      ['v_glow', settings.visual.glow.toFixed(0)],
      ['v_plex', settings.visual.plex.toFixed(2)],
      ['v_detail', stride]
    ];
    for (const [id, val] of pairs) setText(id, val);

    const sync = (id, v) => { const el = byId(id); if (!el) return; if (el.type === 'checkbox') el.checked = !!v; else el.value = v; };
    sync('waveCount', settings.wave.count);
    sync('amplitude', settings.wave.amplitude);
    sync('autoAmplitude', settings.wave.autoAmplitude);
    sync('frequency', settings.wave.frequency);
    sync('speed', settings.wave.speed);
    sync('minGap', settings.wave.minGap);
    sync('autoMinGap', settings.wave.autoMinGap);

    sync('spread', settings.wave.spread);
    sync('bandCenter', settings.wave.bandCenter);

    sync('shape', settings.wave.shape);
    sync('pulseDuty', settings.wave.pulseDuty);

    sync('direction', settings.wave.direction);
    sync('flowAngle', settings.wave.flowAngleDeg);
    sync('tiltDeg', settings.wave.tiltDeg);

    sync('turbType', settings.turbulence.type);
    sync('turbInt', settings.turbulence.intensity);
    sync('turbScale', settings.turbulence.scale);
    sync('turbSpeed', settings.turbulence.speed);
    byId('noiseSeed').value = settings.turbulence.seed;

    sync('interMode', settings.interaction.mode);
    sync('interStrength', settings.interaction.strength);
    sync('interRadius', settings.interaction.radius);
    sync('autoInterRadius', settings.interaction.autoRadius);

    sync('spring', settings.physics.spring);
    sync('neighbor', settings.physics.neighbor);
    sync('damping', settings.physics.damping);
    sync('sepK', settings.physics.sepK);
    sync('keepInside', settings.physics.keepInside);

    sync('lineWidth', settings.visual.lineWidth);
    sync('lineStyle', settings.visual.lineStyle);
    sync('colorMode', settings.visual.colorMode);
    sync('lineColor', settings.visual.lineColor);
    sync('bgColor', settings.visual.bgColor);
    sync('glowEnabled', settings.visual.glowEnabled);
    sync('glow', settings.visual.glow);
    sync('glowColor', settings.visual.glowColor);
    sync('blendMode', settings.visual.blendMode);
    sync('plexEnabled', settings.visual.plexEnabled);
    sync('plex', settings.visual.plex);

    sync('detail', stride);
    sync('autoDetail', settings.system.autoDetail);

    byId('pauseBtn').textContent = settings.system.paused ? 'Resume' : 'Pause';

    setText('ampHint', `Safe amplitude ≤ ${settings.internal.amplitudeCap}px`);
    updateVisibility();
  }

  // ---------- Boot ----------
  function boot() {
    resize();
    for (let i=0; i<settings.wave.count; i++) layers.push(new Layer(i));
    ensureLayerCount();
    initUI();
    // React to layout changes
    const ro = new ResizeObserver(() => resize());
    ro.observe(canvas);
    last = performance.now();
    applyContextLimits();
    requestAnimationFrame(loop);
  }
  boot();
})();
</script>
</body>
</html>